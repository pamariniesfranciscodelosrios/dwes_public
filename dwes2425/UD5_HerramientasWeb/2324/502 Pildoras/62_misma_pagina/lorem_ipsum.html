<p>&nbsp;<iframe src="//www.youtube.com/embed/pr_1Ia1_Gs4" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></p>
<p>&nbsp;</p>
<p>El Segundo&nbsp;<strong>libro que hemos elegido incluir en esta&nbsp;<a href="https://producthackers.com/es/articulos/nature-software-development/">serie de rese&ntilde;as</a>&nbsp;es&nbsp;<em>The Pragmatic Programmer</em>,</strong>&nbsp;de&nbsp;<em>Dave Thomas y Andrew Hunt</em>. Aunque no lo hayas le&iacute;do, seguramente tengas referencias sobre &eacute;l. Se trata de una de las obras que m&aacute;s he o&iacute;do recomendar entre desarrolladores desde que se editara hace ya veinte a&ntilde;os. Con motivo de este aniversario, de hecho, se ha lanzado una edici&oacute;n revisada. Es esta la que comentaremos aqu&iacute;.</p>
<p><strong><em>The Pragmatic Programmer</em>&nbsp;es un texto diverso sobre los diferentes aspectos del desarrollo de software</strong>&nbsp;que, en opini&oacute;n de los autores, deben considerarse para ser un buen programador. A lo largo de nueve cap&iacute;tulos, se nos presentan diferentes componentes de la disciplina, desde la filosof&iacute;a que debe adoptar el programador pragm&aacute;tico hasta cuestiones t&eacute;cnicas como la concurrencia. El nivel de abstracci&oacute;n presentado var&iacute;a seg&uacute;n el tema, de manera que&nbsp;<strong>en algunas secciones encontramos ejemplos de c&oacute;digo o herramientas concretas, mientras que otras se centran en la reflexi&oacute;n</strong>&nbsp;sobre cuestiones de m&aacute;s alto nivel.</p>
<p>&nbsp;</p>
<h2 class="wp-block-heading">El programador pragm&aacute;tico</h2>
<p>Pero,&nbsp;<strong>&iquest;qu&eacute; es un programador pragm&aacute;tico?</strong>&nbsp;En esencia, se trata de un profesional que se preocupa por hacer bien su trabajo. Esto es f&aacute;cil enunciarlo como principio, otra cosa es llevarlo a la pr&aacute;ctica de manera efectiva. El programador pragm&aacute;tico, en primera instancia, toma&nbsp;<strong>responsabilidad</strong>&nbsp;sobre lo que hace, mantiene la&nbsp;<strong>entrop&iacute;a del software bajo control</strong>, desarrolla&nbsp;<strong>&uacute;nicamente lo necesario</strong>&nbsp;y mantiene su&nbsp;<strong>portfolio de conocimientos</strong>&nbsp;actualizado. Tambi&eacute;n se preocupa por cuidar la&nbsp;<strong>comunicaci&oacute;n</strong>&nbsp;con todos los implicados en el desarrollo.</p>
<p>Bajando un poco m&aacute;s a nivel t&eacute;cnico, el programador pragm&aacute;tico realiza un&nbsp;<strong>buen dise&ntilde;o de software</strong>. Para conseguir esto, sigue una serie de principios y buenas pr&aacute;cticas, como por ejemplo&nbsp;<em>DRY (Don&rsquo;t Repeat Yourself), Evitar las ventanas rotas, Ortogonalidad, Reversibilidad</em>&nbsp;o&nbsp;<em>desarrollo de Tracer Bullets.</em>&nbsp;Tambi&eacute;n es importante el dominio de las herramientas, como los editores de&nbsp;<em>texto plano</em>&nbsp;(como formato que resiste el paso del tiempo), el&nbsp;<em>debugger</em>&nbsp;y el&nbsp;<em>control de versiones</em>. Algo que siempre me ha llamado la atenci&oacute;n es la recomendaci&oacute;n de llevar un&nbsp;<strong>diario de ingenier&iacute;a</strong>, donde queden registrados, adem&aacute;s de las tareas completadas, los puntos de inter&eacute;s en el proceso de desarrollo (bocetos, m&eacute;tricas, aprendizajes, etc).</p>
<blockquote class="wp-block-quote">
<p><em>Es imposible escribir un software perfecto</em></p>
</blockquote>
<h3 class="wp-block-heading">La paranoia pragm&aacute;tica</h3>
<p>Es imposible escribir un software perfecto. De hecho nunca est&aacute; del todo bien ni, en realidad, del todo mal (siempre que funcione). Navegar en este espacio de incertidumbre genera que los desarrolladores tengan una inseguridad continua sobre lo que est&aacute;n haciendo. De hecho, esto es hasta algo deseable.</p>
<p>La paranoia pragm&aacute;tica nos propone un enfoque de&nbsp;<strong>desarrollo &laquo;a la defensiva&raquo;,</strong>&nbsp;en el que dise&ntilde;amos usando&nbsp;<strong>contratos</strong>, hacemos&nbsp;<strong>programas que fallan pronto</strong>&nbsp;(<em>dead programs tell no lies)</em>&nbsp;y&nbsp;<strong>nos protegemos de lo imposible</strong>&nbsp;de forma asertiva (s&iacute;,&nbsp;<em>assert</em>&nbsp;no es s&oacute;lo para los tests).</p>
<blockquote class="wp-block-quote">
<p><em>Una reuni&oacute;n a la que todo el mundo tiene que acudir porque nadie est&aacute; seguro del impacto que puede tener un cambio es un escenario fatal (pero a todos nos suena, &iquest;verdad?)</em></p>
</blockquote>
<h3 class="wp-block-heading">Adaptarse o morir</h3>
<p>&laquo;<em>La reutilizaci&oacute;n no tiene por qu&eacute; ser una preocupaci&oacute;n esencial cuando se construye software, pero pensar en qu&eacute; har&iacute;a falta para hacer el c&oacute;digo reutilizable siempre deber&iacute;a formar parte del esfuerzo de dise&ntilde;o</em>&laquo;. Con esta sentencia tan potente se subraya la necesidad de&nbsp;<strong>construir software flexible</strong>, f&aacute;cil de modificar (<em>bend or break).</em>&nbsp;Este tema en concreto ha dado para escribir otros libros en la materia, pero se mencionan en este algunas herramientas concretas que nos pueden ayudar a conseguir este objetivo, como &laquo;<em>Tell, don&rsquo;t Ask&raquo;</em>, o evitar introducir acoplamiento con globalizaci&oacute;n o el uso incorrecto de la herencia. Estos conceptos, que vienen originalmente de la programaci&oacute;n orientada a objetos, bien entendidos tiene aplicaci&oacute;n aplicaci&oacute;n gen&eacute;rica a cualquier paradigma.</p>
<p>Debemos evitar el miedo a modificar el c&oacute;digo. Una reuni&oacute;n a la que todo el mundo tiene que acudir porque nadie est&aacute; seguro del impacto que puede tener un cambio es un escenario fatal (pero a todos nos suena, &iquest;verdad?).</p>
<p>Otras recomendaciones t&eacute;cnicamente m&aacute;s concretas y muy &uacute;tiles para conseguir un c&oacute;digo flexible son&nbsp;<strong>tratar con eventos</strong>&nbsp;(ya que as&iacute; suele funcionar el mundo real), aplicar la visi&oacute;n cl&aacute;sica del c&oacute;digo como una&nbsp;<strong>transformaci&oacute;n de datos</strong>, y contemplar principios de dise&ntilde;o a las configuraciones (<strong>configuraci&oacute;n est&aacute;tica vs. configuraci&oacute;n como servicio</strong>).</p>
<blockquote class="wp-block-quote">
<p><em>La reutilizaci&oacute;n no tiene por qu&eacute; ser una preocupaci&oacute;n esencial cuando se construye software, pero pensar en qu&eacute; har&iacute;a falta para hacer el c&oacute;digo reutilizable siempre deber&iacute;a formar parte del esfuerzo de dise&ntilde;o</em></p>
</blockquote>
<h3 class="wp-block-heading">Enfrentarse a la tarea de programar</h3>
<p>Programar es una tarea con gran impacto psicol&oacute;gico. Cualquiera que se haya enfrentado al desarrollo de un proyecto de software ha vivido situaciones de desempe&ntilde;o irregular, incertidumbre, miedo a la p&aacute;gina en blanco o s&iacute;ndrome del impostor, entre otros. Es importante saber&nbsp;<strong>enfrentarse a uno mismo</strong>,&nbsp;<strong>escuchar a nuestros instintos</strong>&nbsp;y, sobre todo,&nbsp;<strong>perder el miedo a pedir ayuda</strong>&nbsp;y a apoyarse en el equipo.</p>
<p>Con respecto a las cuestiones t&eacute;cnicas, se hace hincapi&eacute; en saber medir la eficiencia de los algoritmos, la&nbsp;<strong>refactorizaci&oacute;n</strong>, el&nbsp;<strong>testing</strong>, la&nbsp;<strong>seguridad</strong>&nbsp;y el&nbsp;<strong>nombrado</strong>. Estas pr&aacute;cticas y caracter&iacute;sticas se subrayan de forma recurrente en los libros m&aacute;s relevantes sobre desarrollo de software escritos en los &uacute;ltimos 25 a&ntilde;os. Tal vez haya una raz&oacute;n de peso.</p>
<blockquote class="wp-block-quote">
<p><em>Todo el proyecto, de forma &iacute;ntegra, debe ser considerado un proceso de toma de requisitos</em></p>
</blockquote>
<h3 class="wp-block-heading">El proyecto program&aacute;tico</h3>
<p>Los requisitos son tradicionalmente tratados como una especie de tesoro oculto que debemos encontrar a trav&eacute;s de una fase de an&aacute;lisis. Si un proyecto falla entregando valor al cliente, es porque este proceso inicial no se hizo correctamente. Esta afirmaci&oacute;n, tan arraigada en la cultura del desarrollo, no puede ser m&aacute;s err&oacute;nea. En la mayor parte de los inicios de los proyectos los requisitos rara vez existen con forma consistente. Deben ser refinados a trav&eacute;s de un proceso de&nbsp;<strong>feedback continuo</strong>&nbsp;(<em>feedback loop).</em>&nbsp;Para conseguirlo, se deben establecer conversaciones, basadas en&nbsp;<em>mockups</em>&nbsp;o prototipos. Si lo pensamos bien, todo aquello que hacemos en software es un prototipo. Es por esto que se prefiere entregar el software en peque&ntilde;os incrementos.&nbsp;<strong>Todo el proyecto, de forma &iacute;ntegra, debe ser considerado un proceso de toma de requisitos</strong>.</p>
<p>Un proyecto de software se beneficia enormemente del mantenimiento de un&nbsp;<strong>vocabulario com&uacute;n</strong>, sin ambig&uuml;edad, entendido por todas las partes implicadas. Es por esto que es recomendable mantener un&nbsp;<strong>glosario del proyecto</strong>, al que tenga acceso todo el mundo.</p>
<p>Trabajar juntos es otra de las consideraciones importantes a la hora de afrontar un proyecto de forma pragm&aacute;tica. Los programadores, de forma natural, o tal vez por comodidad, tendemos a aislarnos. Seg&uacute;n la&nbsp;<a href="https://en.wikipedia.org/wiki/Conway%27s_law">Ley de Conway</a>,&nbsp;<strong>el software reflejar&aacute; la estructura de la organizaci&oacute;n</strong>. Si no colaboramos, el software se compondr&aacute;n de silos, tanto funcionales como de conocimiento. Existen muchas formas de colaborar en equipos de software, la&nbsp;<em>Code Review</em>&nbsp;quiz&aacute; sea la m&aacute;s extendida. Las pr&aacute;cticas m&aacute;s continuas como&nbsp;<em>Pair Programming</em>&nbsp;y&nbsp;<em>Mob Programming</em>&nbsp;han demostrado su eficacia a la hora de resolver determinados problemas, y conviene tambi&eacute;n darles una oportunidad.</p>
<p>Se hace una rese&ntilde;a en el libro tambi&eacute;n a&nbsp;<em>Agile</em>, y, c&oacute;mo no, se menciona el entendimiento err&oacute;neo que se hace de sus principios a trav&eacute;s de la aplicaci&oacute;n de metodolog&iacute;as e implementaciones sin cuidar los fundamentos. Un proyecto pragm&aacute;tico favorecer&aacute; la&nbsp;<strong>respuesta al cambio</strong>, no primar&aacute; los procedimientos sobre las interacciones, y abrazar&aacute; la&nbsp;<strong>excelencia t&eacute;cnica</strong>, que nos permitir&aacute; entrar en un&nbsp;<strong>bucle de cambio continuo</strong>.</p>
<blockquote class="wp-block-quote">
<p><em>El software reflejar&aacute; la estructura de la organizaci&oacute;n</em></p>
</blockquote>
<h3 class="wp-block-heading">Conclusi&oacute;n</h3>
<p>Le&iacute; por primera vez este libro hace ya muchos a&ntilde;os, cuando mi situaci&oacute;n profesional era bien distinta por motivos de lo m&aacute;s variados. Recuerdo que entonces la contundencia de las ideas me dej&oacute; un profundo poso. Algunas de las met&aacute;foras y principios que se exponen han resonado en mi cabeza de forma recurrente, influy&eacute;ndome sin duda en muchas de las decisiones que he tomado. Sin embargo, al releerlo en esta nueva edici&oacute;n, he tenido la impresi&oacute;n de que revisaba internamente mi entendimiento sobre muchos de estos conceptos. El libro, sin embargo, es el mismo, con alguna actualizaci&oacute;n. Es curioso c&oacute;mo el texto puede llegar a impactar de forma diferente dependiendo de las circunstancias de cada uno. Sin duda se trata de una de esas obras que hay que volver a leer cada cierto tiempo. Imprescindible.</p>
<h3 class="wp-block-heading">Los autores</h3>
<p>Dave Thomas y Andy Hunt, conocidos como The Pragmatic Programmers, son dos de las voces m&aacute;s reconocidas en el mundo de la divulgaci&oacute;n dentro del software. Ambos forman parte del ilustre grupo de los 17 firmantes del&nbsp;<a href="https://agilemanifesto.org/" target="_blank" rel="noopener noreferrer" data-token-index="3" data-reactroot="">Manifiesto Agile</a>, y juntos fundaron&nbsp;<a href="https://pragprog.com/" target="_blank" rel="noopener noreferrer" data-token-index="5" data-reactroot="">The Pragmatic Bookshelf</a>, una editorial dedicada a la publicaci&oacute;n de obras sobre desarrollo de software de alta calidad.</p>